&emsp;
# thread

C++支持多线程编程，主要使用的是线程库<thread>

>Example 1: 创建线程使用 std::thread 类
```c++
#include <iostream>
#include <thread>  

void threadFunctionA()
{
	std::cout << "Run New thread: 1" << std::endl;
}
void threadFunctionB(int n)
{
	std::cout << "Run New thread: "<< n << std::endl;
}

int main()
{
	std::cout << "Run Main Thread" << std::endl;

	std::thread newThread1(threadFunctionA);
	std::thread newThread2(threadFunctionB,2);

	newThread1.join();
	newThread2.join();

	return 0;
}
```

上述示例中，我们创建了两个线程newThread1和newThread2，使用函数threadFunctionA()和threadFunctionB()作为线程的执行函数，并使用join()函数等待线程执行完成。

&emsp;
>Example 2: 执行函数有引用参数
```c++
#include <iostream>
#include <thread>    //必须包含<thread>头文件

void threadFunc(int &arg1, int arg2)
{
	arg1 = arg2;
	std::cout << "arg1 = " << arg1 << std::endl;
}

int main()
{
    std::cout << "Run Main Thread!" << std::endl;
	int a = 1;
	int b = 5;
	std::thread newTh(threadFunc, a, b);  //此处会报错
	newTh.join();
	return 0;
}
```
注意： 若编译上述代码，编译器会报错


这是因为 thread 在传递参数时，是以右值传递的，如果要传递一个左值可以使用std::ref 和 std::cref

&emsp;
>Example 3
- std::ref 可以包装按引用传递的值为右值
- std::cref 可以包装按const引用传递的值为右值
```c++
#include <iostream>
#include <thread>    //必须包含<thread>头文件

void threadFunc(int &arg1, int arg2)
{
	arg1 = arg2;
	std::cout << "New Thread arg1 = " << arg1 << std::endl;
}

int main()
{
	std::cout << "Run Main Thread!" << std::endl;
	int a = 1, b = 5;
	std::thread newTh(threadFunc, std::ref(a), b);  //使用ref
	newTh.join();
	return 0;
}
```